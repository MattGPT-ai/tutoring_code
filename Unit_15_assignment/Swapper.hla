// File: SwapProgram
program SwapProgram;
#include( "stdlib.hhf" );
static

X : int8 := 0; // the user data
Y : int8 := 0;
Z : int8 := 0;
// this procedure swaps the contents of i and j, 
// 2 reference parameters
// although byte variables are passed as parameters, 
// no stack alignment is necessary because 32-bit 
// addresses are being sent instead
procedure swap( var i: int8; var j : int8 ); @nodisplay; @noframe;
// uses the registers EDX, ECX and EBX
static

dReturnAddress : dword;
iTemporary : int16;
holdX : int32;
holdY : int32;
holdZ : int32;
begin swap;
// entry sequence

pop( dReturnAddress ); // This is the return address
pop(EDX); // This is the address of Z
pop( ECX ); // This is the address of Y
pop( EBX ); // This is the address of X
// push back the return address
push( dReturnAddress );

//stdout.put(EBX);
//stdout.newln();
//stdout.put([EBX])
//stdout.newln()
//stdout.put(ECX);
//stdout.newln();
//stdout.put([ECX])
//stdout.newln()

mov([EBX], holdX);
mov([ECX], holdY);

cmp(holdX, ECX);
jg swapXAndY;
//cmp(EBX, EDX);
//jg swapXAndZ;
// begin sub-task
jmp exitSequence;

swapXAndY:
mov( [EBX], ESI ); // ESI = y
mov( SI, iTemporary ); // temporary = y
mov( [ECX], ESI ); // ESI = x
mov( SI, [EBX] ); // j = x
mov( iTemporary, SI ); // ESI = y
mov( SI, [ECX] ); // x = temporary = y

exitSequence:
// exit sequence
// transfer control 
ret( ) ;
end swap;

begin SwapProgram;
stdout.put( "gimme a value to swap: " );
stdin.get(X);
stdout.put( "gimme another value to swap:" );
stdin.get(Y);
stdout.put("gimme a third value to swap: ");
stdin.get(Z);

lea(EAX, X); // get address of X
push( EAX );//push x
lea(EAX, Y); // get address of Y
push( EAX );//push y
lea(EAX, Z);// get address of Z
push(EAX);//push z

stdout.put( "swapping...", nl );
call swap;

stdout.put( "X = ", X, nl );

stdout.put( "Y = ", Y, nl );
end SwapProgram;